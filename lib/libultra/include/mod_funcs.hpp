/********************************************************************************
 * File: mod_funcs.hpp
 * Author: ppkantorski
 * Description:
 *   This header file contains function declarations and utility functions for IPS
 *   binary generations. These functions are used in the Ultrahand Overlay project
 *   to convert `.pchtxt` mods into `.ips` binaries.
 *
 *   For the latest updates and contributions, visit the project's GitHub repository.
 *   (GitHub Repository: https://github.com/ppkantorski/Ultrahand-Overlay)
 *
 *   Note: Please be aware that this notice cannot be altered or removed. It is a part
 *   of the project's documentation and must remain intact.
 * 
 *  Licensed under both GPLv2 and CC-BY-4.0
 *  Copyright (c) 2024 ppkantorski
 ********************************************************************************/

#pragma once
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <sys/stat.h>
#include "debug_funcs.hpp"
#include "path_funcs.hpp"
#include "hex_funcs.hpp"

const std::string IPS32_HEAD_MAGIC = "IPS32";
const std::string IPS32_FOOT_MAGIC = "EEOF";
//const std::string CHEAT_HEADER = "// auto generated by pchtxt2cheat\n\n";
const std::string CHEAT_TYPE = "04000000";
const std::string CHEAT_EXT = ".txt";
const std::string CHEAT_ENCODING = "ascii";



/**
 * @brief Checks if a cheat already exists in the cheat file.
 * @param cheatFilePath The path to the cheat file.
 * @param newCheat The new cheat to check.
 * @return True if the cheat exists, otherwise false.
 */
bool cheatExists(const std::string &cheatFilePath, const std::string &newCheat) {
    std::ifstream cheatFile(cheatFilePath);
    if (!cheatFile) {
        return false;
    }
    std::string line;
    while (std::getline(cheatFile, line)) {
        if (line == newCheat) {
            return true;
        }
    }
    return false;
}

/**
 * @brief Appends a new cheat to the cheat file.
 * @param cheatFilePath The path to the cheat file.
 * @param newCheat The new cheat to append.
 */
void appendCheatToFile(const std::string &cheatFilePath, const std::string &newCheat) {
    std::ofstream cheatFile(cheatFilePath, std::ios::app);
    cheatFile << newCheat << std::endl;
}

/**
 * @brief Extracts the cheat name from the given file path.
 * @param filePath The full file path.
 * @return The extracted cheat name.
 */
std::string extractCheatName(const std::string &filePath) {
    size_t lastSlash = filePath.find_last_of("/\\");
    if (lastSlash == std::string::npos) {
        return "";
    }
    size_t secondLastSlash = filePath.find_last_of("/\\", lastSlash - 1);
    if (secondLastSlash == std::string::npos) {
        return "";
    }
    std::string lastDir = filePath.substr(secondLastSlash + 1, lastSlash - secondLastSlash - 1);
    std::string fileName = filePath.substr(lastSlash + 1);
    size_t dotPos = fileName.find_last_of('.');
    if (dotPos != std::string::npos) {
        fileName = fileName.substr(0, dotPos);
    }

    // If lastDir contains " - ", extract the part after " - "
    size_t dashPos = lastDir.find(" - ");
    std::string cheatName = lastDir;
    if (dashPos != std::string::npos) {
        cheatName = lastDir.substr(dashPos + 3);
    }

    return cheatName + " " + fileName;
}

// Helper function to determine if a string is a valid title ID
bool isValidTitleID(const std::string &str) {
    if (str.length() != 16) return false;
    for (char c : str) {
        if (!std::isxdigit(c)) return false; // Check if each character is a hexadecimal digit
    }
    return true;
}

// Function to find the title ID in the text, avoiding the @nsobid- line
std::string findTitleID(const std::string &text) {
    size_t nsobidPos = text.find("@nsobid-");
    size_t startPos = (nsobidPos != std::string::npos) ? nsobidPos + 40 + 8 : 0; // Skip past @nsobid- and its value

    for (size_t i = startPos; i <= text.length() - 16; ++i) {
        std::string potentialID = text.substr(i, 16);
        if (isValidTitleID(potentialID)) {
            return potentialID;
        }
    }
    return "";
}


/**
 * @brief Converts a .pchtxt file to a cheat file.
 * @param pchtxtPath The file path to the .pchtxt file.
 * @param cheatName The name of the cheat.
 * @param outCheatPath The file path for the output cheat file.
 * @return True if the conversion was successful, false otherwise.
 */
bool pchtxt2cheat(const std::string &pchtxtPath, std::string cheatName = "", std::string outCheatPath = "") {
    logMessage("Starting pchtxt2cheat with pchtxtPath: " + pchtxtPath);

    std::ifstream pchtxtFile(pchtxtPath);
    if (!pchtxtFile) {
        logMessage("Error: Unable to open file " + pchtxtPath);
        return false;
    }

    if (cheatName.empty()) {
        cheatName = extractCheatName(pchtxtPath);
        if (cheatName.empty()) {
            logMessage("Error: Unable to extract cheat name from path " + pchtxtPath);
            return false;
        }
    }
    //-logMessage("Cheat name determined: " + cheatName);

    std::string pchtxt((std::istreambuf_iterator<char>(pchtxtFile)), std::istreambuf_iterator<char>());
    size_t nsobidPos = pchtxt.find("@nsobid-");
    if (nsobidPos == std::string::npos) {
        logMessage("Error: Could not find bid in pchtxt file, the file is likely invalid.");
        return false;
    }

    std::string bid = pchtxt.substr(nsobidPos + 8, 40);
    std::string bidShort = bid.substr(0, 16);
    //logMessage("BID extracted: " + bidShort);

    std::string tid = findTitleID(pchtxt);
    if (tid.empty()) {
        logMessage("Error: Could not find TID in pchtxt file, the file is likely invalid.");
        return false;
    }
    //logMessage("TID extracted: " + tid);

    std::string cheatFilePath;

    if (outCheatPath.empty()) {
        std::string folderPath = "sdmc:/atmosphere/contents/" + tid + "/cheats/";
        createDirectory(folderPath);
        cheatFilePath = folderPath + bidShort + CHEAT_EXT;
    } else {
        cheatFilePath = outCheatPath;
    }
    //logMessage("Cheat file path: " + cheatFilePath);

    std::ifstream existingCheatFile(cheatFilePath);
    bool cheatNameExists = false;
    if (existingCheatFile) {
        std::string line;
        while (std::getline(existingCheatFile, line)) {
            if (line == "[" + cheatName + "]") {
                cheatNameExists = true;
                break;
            }
        }
    }
    existingCheatFile.close();

    std::ofstream outCheatFile(cheatFilePath, std::ios::app);
    if (!outCheatFile) {
        logMessage("Error: Unable to create cheat file " + cheatFilePath);
        return false;
    }

    //logMessage("Writing to " + cheatFilePath);

    if (!cheatNameExists) {
        outCheatFile << "[" << cheatName << "]\n";
    }

    int offset = 0;
    std::istringstream iss(pchtxt);
    std::string line;
    while (std::getline(iss, line)) {
        line = trim(line);
        if (line.empty() || line[0] == '#') {
            continue;
        }

        if (line.find("@flag offset_shift ") == 0) {
            std::string offsetStr = line.substr(19);
            offset = (offsetStr.find("0x") == 0 ? std::strtol(offsetStr.c_str(), nullptr, 16) : std::strtol(offsetStr.c_str(), nullptr, 10)) - 0x100;
            //logMessage("Offset shift found: " + std::to_string(offset));
            continue;
        }

        if (line.find("@enabled") == 0) {
            //logMessage("Found @enabled, starting cheat processing");
            continue;
        }

        if (line.find("@stop") == 0) {
            //logMessage("Found @stop, ending cheat processing");
            break;
        }

        size_t spacePos = line.find(' ');
        if (spacePos == std::string::npos) {
            //logMessage("Skipping malformed line: " + line);
            continue;
        }

        std::string addrStr = line.substr(0, spacePos);
        std::string valStr = line.substr(spacePos + 1);

        if (addrStr.find_first_not_of("0123456789abcdefABCDEF") != std::string::npos || valStr.find_first_not_of("0123456789abcdefABCDEF") != std::string::npos) {
            //logMessage("Skipping invalid line: " + line);
            continue;
        }

        int codeOffset = std::strtol(valStr.c_str(), nullptr, 16) + offset;
        char buffer[9];
        snprintf(buffer, sizeof(buffer), "%08X", codeOffset);
        std::string cheatLine = CHEAT_TYPE + " " + addrStr + " " + hexToReversedHex(buffer);
        if (!cheatExists(cheatFilePath, cheatLine)) {
            outCheatFile << cheatLine << "\n";
            logMessage("Cheat line added: " + cheatLine);
        } else {
            logMessage("Cheat already exists: " + cheatLine);
        }
    }

    outCheatFile.close();
    //logMessage("Finished writing cheat file.");
    return true;
}

// Corrected helper function to convert values to big-endian format
uint32_t toBigEndian(uint32_t value) {
    return ((value & 0x000000FF) << 24) |
           ((value & 0x0000FF00) << 8)  |
           ((value & 0x00FF0000) >> 8)  |
           ((value & 0xFF000000) >> 24);
}

uint16_t toBigEndian(uint16_t value) {
    return ((value & 0x00FF) << 8) |
           ((value & 0xFF00) >> 8);
}

// Helper function to convert a vector of bytes to a hex string for logging
#include <iomanip> // Include this header for std::setw and std::setfill
std::string hexToString(const std::vector<uint8_t>& bytes) {
    std::ostringstream oss;
    for (uint8_t byte : bytes) {
        oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
    }
    return oss.str();
}


/**
 * @brief Converts a .pchtxt file to an IPS file using fstream.
 *
 * This function reads the contents of a .pchtxt file, extracts the address-value pairs,
 * and generates an IPS file with the provided output folder.
 *
 * @param pchtxtPath The file path to the .pchtxt file.
 * @param outputFolder The folder path for the output IPS file.
 * @return True if the conversion was successful, false otherwise.
 */
bool pchtxt2ips(const std::string& pchtxtPath, const std::string& outputFolder) {
    std::ifstream pchtxtFile(pchtxtPath);
    if (!pchtxtFile) {
        logMessage("Error: Unable to open file " + pchtxtPath);
        return false;
    }

    std::vector<std::pair<uint32_t, std::vector<uint8_t>>> patches;
    std::string line;
    uint32_t lineNum = 0;
    std::string nsobid;
    int offset = 0; // Default offset

    uint32_t address;
    uint8_t byte;
    std::vector<uint8_t> valueBytes;

    std::string addressStr, valueStr;
    
    std::istringstream iss;

    while (std::getline(pchtxtFile, line)) {
        ++lineNum;
        if (line.empty() || line.front() == '@') {
            if (line.find("@nsobid-") == 0) {
                nsobid = line.substr(8);
            }
            if (line.find("@flag offset_shift ") == 0) {
                std::string offsetStr = line.substr(19);
                offset = (offsetStr.find("0x") == 0 ? std::strtol(offsetStr.c_str(), nullptr, 16) : std::strtol(offsetStr.c_str(), nullptr, 10));
            }
            continue;  // Skip empty lines and lines starting with '@'
        }

        iss.clear();
        iss.str(line);
        
        addressStr = "";
        valueStr = "";
        if (!(iss >> addressStr >> valueStr)) {
            continue;
        }

        char* endPtr;
        address = std::strtoul(addressStr.c_str(), &endPtr, 16) + offset; // Adjust address by offset
        if (*endPtr != '\0') {
            continue;
        }

        for (size_t i = 0; i < valueStr.length(); i += 2) {
            byte = std::stoi(valueStr.substr(i, 2), nullptr, 16);
            valueBytes.push_back(byte);
        }
        
        if (valueBytes.empty()) {
            continue;
        }

        patches.push_back(std::make_pair(address, valueBytes));
        valueBytes.clear();
    }

    if (nsobid.empty()) {
        nsobid = pchtxtPath.substr(pchtxtPath.find_last_of("/\\") + 1);
        nsobid = nsobid.substr(0, nsobid.find_last_of("."));
    }

    pchtxtFile.close();

    // Trim any newline characters from nsobid
    nsobid = trimNewline(trim(nsobid));

    std::string ipsFileName = nsobid + ".ips";
    std::string ipsFilePath = outputFolder + ipsFileName;

    std::ofstream ipsFile(ipsFilePath, std::ios::binary);
    if (!ipsFile) {
        logMessage("Error: Unable to create IPS file " + ipsFilePath);
        return false;
    }

    ipsFile.write(IPS32_HEAD_MAGIC.c_str(), IPS32_HEAD_MAGIC.size());

    uint16_t valueLength;
    for (const auto& patch : patches) {
        uint32_t bigEndianAddress = toBigEndian(patch.first);  // Convert address to big-endian
        //logMessage("Writing address: " + std::to_string(patch.first) + " as big-endian: " + std::to_string(bigEndianAddress)); // Log the address
        ipsFile.write(reinterpret_cast<const char*>(&bigEndianAddress), sizeof(bigEndianAddress));  // Write address

        valueLength = toBigEndian(static_cast<uint16_t>(patch.second.size()));  // Convert length to big-endian
        //logMessage("Writing length: " + std::to_string(patch.second.size()) + " as big-endian: " + std::to_string(valueLength)); // Log the length
        ipsFile.write(reinterpret_cast<const char*>(&valueLength), sizeof(valueLength));  // Write length of value

        ipsFile.write(reinterpret_cast<const char*>(patch.second.data()), patch.second.size());  // Write value
        //logMessage("Writing value: " + hexToString(patch.second)); // Log the value
    }

    ipsFile.write(IPS32_FOOT_MAGIC.c_str(), IPS32_FOOT_MAGIC.size());
    ipsFile.close();

    return true;
}
